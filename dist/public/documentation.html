<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, shrink-to-fit=no">
  <link rel="icon" type="image/svg+xml" href="images/brands/beyond-decentralized/favicon.svg">
  <link rel="icon" type="image/png" href="images/brands/beyond-decentralized/favicon.png">
  <title>Documentation</title>
  <meta name="description" content="Your ThemeForest item Name and description">
  <meta name="author" content="Artem.V.Shamsutdinov@beyond-decentralized.world">

  <!-- Stylesheet
============================== -->
  <!-- Bootstrap -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/bootstrap/css/bootstrap.min.css" />
  <!-- Font Awesome Icon -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/font-awesome/css/all.min.css" />
  <!-- Magnific Popup -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/magnific-popup/magnific-popup.min.css" />
  <!-- Highlight Syntax -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/highlight.js/styles/github.css" />
  <!-- Custom Stylesheet -->
  <link rel="stylesheet" type="text/css" href="assets/css/stylesheet.css" />

  <style>
    header {
      padding-left: 15px;
      padding-top: 25px;
    }

    header .header__logo img {
      width: 85px;
      height: 44px;
    }

    header a.logo-text {
      color: white;
      font-size: 19px;
      line-height: 19px;
      margin-bottom: 15px;
      margin-top: 7px;
    }

    header table {
      margin-bottom: 0px;
    }

    header td {
      padding: 0rem;
      text-align: left;
      border-bottom: 0px;
    }

    .idocs-navigation>.nav {
      padding-bottom: 0px;
    }

    .idocs-navigation>.bottom-external.nav {
      padding: 0px;
    }

    .idocs-navigation>.site-navigation.nav {
      padding-top: 0px;
    }

    .idocs-navigation>.top-external.nav {
      padding-bottom: 0px;
    }
  </style>
</head>

<body data-spy="scroll" data-target=".idocs-navigation" data-offset="125">

  <!-- Preloader -->
  <div class="preloader">
    <div class="lds-ellipsis">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>
  </div>
  <!-- Preloader End -->

  <!-- Document Wrapper   
=============================== -->
  <div id="main-wrapper">

    <!-- Content
  ============================ -->
    <div id="content" role="main">

      <!-- Sidebar Navigation
	============================ -->
      <div class="idocs-navigation bg-dark docs-navigation-dark">
        <header>
          <div class="header__logo">
            <table>
              <tr>
                <td>
                  <img src="./images/brands/beyond-decentralized/beyond-decentralized-logo.svg"
                    alt="Beyond Decentralized logo" />
                </td>
                <td>
                  <a class="logo-text" href="https://github.com/sponsors/beyond-decentralized/">
                    Beyond Decentralized
                  </a>
                </td>
              </tr>
            </table>
          </div>
        </header>
        <ul class="top-external nav flex-column ">
          <li class="nav-item"><a class="nav-link" href="./index.html">About</a></li>
        </ul>
        <ul class="site-navigation nav flex-column ">
          <li class="nav-item"><a class="nav-link active" href="#documentation">Documentation</a>
            <ul class="nav flex-column">
              <li class="nav-item"><a class="nav-link" href="#introduction">Introduction</a></li>
              <li class="nav-item"><a class="nav-link" href="#technologies">Techologies</a></li>
              <li class="nav-item"><a class="nav-link" href="#the-story">The Story</a></li>
            </ul>
          </li>
          <li class="nav-item"><a class="nav-link" href="#Autonomous-Interdependent-Repositories">AIR</a>
            <ul class="nav flex-column">
              <li class="nav-item"><a class="nav-link" href="#AIR-relational">Relational</a></li>
              <li class="nav-item"><a class="nav-link" href="#AIR-ids">IDs</a></li>
              <li class="nav-item"><a class="nav-link" href="#AIR-transaction-logs">Transaction Logs</a></li>
              <li class="nav-item"><a class="nav-link" href="#AIR-autonomous">Autonomous</a></li>
              <li class="nav-item"><a class="nav-link" href="#AIR-interdependent">Interdependent</a></li>
            </ul>
          </li>
          <li class="nav-item"><a class="nav-link" href="#AIRport">AIRport</a>
            <ul class="nav flex-column">
              <li class="nav-item"><a class="nav-link" href="#AIRport-ORM">ORM & State</a></li>
              <li class="nav-item"><a class="nav-link" href="#AIRport-API">API</a></li>
              <li class="nav-item"><a class="nav-link" href="#AIRport-Transactions-n-Scope">Transactions & Scope</a>
              </li>
              <li class="nav-item"><a class="nav-link" href="#AIRport-Synchronization">Synchronization</a></li>
            </ul>
          </li>
          <li class="nav-item"><a class="nav-link" href="#AIRbridge">AIRbridge</a>
            <ul class="nav flex-column">
              <li class="nav-item"><a class="nav-link" href="#AIRbridge-Blockchain">Blockchain</a></li>
              <li class="nav-item"><a class="nav-link" href="#AIRbridge-SSO">SSO</a></li>
              <li class="nav-item"><a class="nav-link" href="#AIRbridge-Transfer">Transfer</a></li>
              <li class="nav-item"><a class="nav-link" href="#AIRbridge-Validation">Validation</a>
              </li>
            </ul>
          </li>
          <li class="nav-item"><a class="nav-link" href="#AIRway">AIRway</a>
          </li>
          <li class="nav-item"><a class="nav-link" href="#Highway">Highway</a>
          </li>
          <li class="nav-item"><a class="nav-link" href="#Maglev">Maglev</a>
          </li>
        </ul>
        <ul class="bottom-external nav flex-column ">
          <li class="nav-item"><a class="nav-link" href="./blog.html">Blog</a></li>
          <li class="nav-item"><a class="nav-link" href="./sponsors.html">Sponsors</a></li>
        </ul>
      </div>

      <!-- Docs Content
	============================ -->
      <div class="idocs-content">
        <div class="container">

          <!-- Getting Started
		============================ -->
          <section id="documentation">
            <h1>Documentation</h1>
            <h2 id="introduction">Introduction</h2>
            <p class="lead">Beyond Decentralized technology enables <a href="index.html">Fair
              Data Ownership and Independent Software Development</a>.</p>
            <hr>
            <div class="row">
              <div class="col-sm-6 col-lg-4">
                <ul class="list-unstyled">
                  <li><strong>Version:</strong> 0.3.2</li>
                </ul>
              </div>
              <div class="col-sm-6 col-lg-4">
                <ul class="list-unstyled">
                  <li><strong class="font-weight-700">Created:</strong> July 16th, 2022</li>
                  <li><strong>Updated:</strong> August 11th, 2022</li>
                </ul>
              </div>
            </div>
            <p class="alert alert-info">Please feel free to email
              <a target="_blank" href="mailto:Artem.V.Shamsutdinov@beyond-decentralized.world">Artem</a>
              if you need information beyond what is covered here.
            </p>
            <p>
              At the core of Beyond Decentralized stack is
              <a href="https://en.wikipedia.org/wiki/Relational_database">relational
                database</a> technology. It
              structures data in relational tables and exposes its structure as <a
                href="https://en.wikipedia.org/wiki/Database_schema">schemas</a>.
              Developers are able to read these schemas and understand how data is structured.
              In turn, Applications are able
              to join data across multiple schemas and present it to the users.
            </p>
            <p><a href="https://patents.google.com/patent/US10902016B2">
                Autonomous Interdependent Repositories</a> enable use of relational databases
              in decentralized environments. Data is split into virtual Repositories.
              Repositories reside on user's devices in relational databases. Repository
              transaction logs are stored independently, on shared file systems like
              <a href="https://filecoin.io/">Filecoin</a>.
            </p>
            <p>
              Beyond Decentralized technology stack will be used for:
            <ul>
              <li><a href="https://turbase.app">Turbase DAO</a> is a company with
                the mission of making Applications profitable without selling user's data.
              </li>
              <li><a href="https://dataindependence.net">Data Independence Network LCA PBC</a>
                is an organization with the mission of keeping data in the originating communities.
              </li>
            </ul>


            </p>
          </section>

          <hr class="divider">

          <!-- Tehnologies
		============================ -->
          <section id="technologies">
            <h3>Technologies</h3>
            <p class="lead">Beyond Decentralized is focused on data decentralization
              while keeping data structured and understandable.</p>
            <ol>
              <li>
                <a href="https://github.com/beyond-decentralized/AIRport">AIRport</a> is
                the founding project of Beyond Decentralized. It manages data Repositories
                and controls data access by Applications. It provides:
                <ul>
                  <li>Object Relational Mapping</li>
                  <li>Query and Persistence layer</li>
                  <li>Application VM management</li>
                  <li>Data validation</li>
                  <li>Repository access and maintenance</li>
                </ul>
                <br>
                AIRport runs entirely in-browser and can also run as a native application
                on end user devices.
              </li>
              <li>Highway is an upcoming project that will let organizations
                work on data owned by local communities. It will facilitate
                community storage of data and integrate with AIRport
                for user owned data. Its development is driven by the idea that
                corporations can harmoniously work with locally owned community
                data providers and personal user data. Highway will take application
                interoperability into the distributed world, beyond what data
                decentralization can offer.
              </li>
              <li>Maglev is a future project. It's about letting any number
                of organizations fairly and securely access community owned data.
                It is meant to help existing organizations plug into locally
                sovereign data as well as group and personal data.
              </li>
            </ol>
          </section>

          <hr class="divider">

          <!-- The Story
		============================ -->
          <section id="the-story">
            <h3>The Story of Beyond Decentralized</h3>
            <p>
              In 2015 I wrote "Hans the Organizator" (a family organizer)
              and realized that families would have to store data on someone else's
              servers. So I set off to first write an adapter for cloud storage
              where people could store data under their own accounts. Over time
              that adapter grew to become AIRport.
            </p>
            <p>
              Eventually I made a conceptual breakthrough and I realized that Applications
              can inter-operate on user data. Applications can access user owned data and
              share it solely on the user's devices. For me, that
              changed how applications can be written.
            </p>
            <p>
              All along I had the idea that globally shared data can also be stored
              and used in a fair way. The idea centered around data staying in the
              communities where it originated. 3rd party Applications
              process the data on communities behalf.
            </p>
            <p>
              Autonomous Interdependent Repositories allow any number of databases
              to be jointly processed on execution nodes.
              Now, in 2022, <a href="https://beyond-decentralized.world/2022/Beyond_Decentralized.html">I realized</a>
              that it is possible to combine databases on a
              network of independently operated execution nodes. This means that
              multiple data hosting organizations can interoperate in a fair data
              ecosystem.
            </p>
            <p>
              Artem V. Shamsutdinov
            </p>
          </section>

          <hr class="divider">

          <!-- Autonomous Interdependent Repositories
		============================ -->
          <section id="Autonomous-Interdependent-Repositories">
            <h2>Autonomous Interdependent Repositories</h2>
            <p class="lead mb-5">
              Autonomous Interdependent Repositories are about taking relational data
              and breaking it up into pieces that can be shared across devices.
            </p>
            <p>
              Any dataset presented to the user at a given time is limited. For example
              a thread on a forum is a limited set of data. Repository represents such
              a dataset. Repositories are meant to be small and focused.
            </p>
            <p>Using data presentation as a guidance Applications define Repository
              boundaries. For
              example menu contents covered by one Repository
              while forum threads backed by separate Repositories.
            </p>
            <p>
              Repositories can aggregate data
              computed based on contents of other repositories.
            </p>
          </section>


          <!-- AIR -  Relational
		============================ -->
          <section id="AIR-relational">
            <h3>AIR - Relational</h3>
            <p>
              Repositories are loaded into relational databases. A Repository can
              span any number of relational tables.
            </p>
            <img src="./images/AIR_diagram.png" class="img-fluid" alt="A I R Repositories in tables">
            <div class="alert alert-info mb-4">
              <span class="badge badge-info text-uppercase">Example:</span> AIRport
              database contains 2 schemas,
              one from Event App and one from Chat App. Event App Schema contains the
              EVENTS table and Chat App Schema contains the POSTS table. There are 3
              Repositories. 'Event A' Repository spans both tables and schemas.
              Repository 'Chat B' is contained in the POSTS table. Repository 'Chat C'
              spans tables in the Chat App Schema (other tables are not pictured).
            </div>
          </section>

          <!-- AIR - IDs
		============================ -->
          <section id="AIR-ids">
            <h3>AIR - IDs</h3>
            <p>
              All records in Repositories are identified by 3 keys:
            </p>
            <ul>
              <li>
                <b>Repository GUID</b> - a globally unique identifier for the
                repository
              </li>
              <li>
                <b>Actor GUID</b> - a globally unique identifier for the
                "Actor" that created the record.
              </li>
              <li>
                <b>Actor Record ID</b> - a numeric identifier unique to the
                physical database on which the record is created
              </li>
            </ul>
            <p>
              "Actor" is a User, using an Application on a
              Device. In practice it Actor is:
            </p>
            <ul>
              <li>
                A given <b>User</b> - identified by an email address.
              </li>
              <li>
                Using a given <b>Application</b> - identified by the URL of
                the Application (domain + path)
              </li>
              <li>
                via a particular <b>Client</b> - identified
                by the domain of the Client (Ex: "a-user-interface.com")
              </li>
              <li>
                on a particular <b>Database</b> - that resides on a User's device
                and is identified by a random GUID
              </li>
            </ul>
            <p>Applications are different from Clients.
              Applications run in isolated IFrames (from different
              domains), within the AIRport tab. Clients are the UIs that
              use AIRport.
            </p>
          </section>

          <!-- Header
		============================ -->
          <section id="AIR-transaction-logs">
            <h3>AIR - Transaction Logs</h3>
            <p>
              Repositories are stored "at rest" on decentralized file systems as
              Transaction logs. Each Repository gets its own, independent
              Transaction log. Transaction logs are structured in:
            </p>
            <ul>
              <li>
                <b>Transaction History</b> - this is a record of the transaction, with a
                unique identifier and a timestamp of when the transaction took place.
                <ul>
                  <b>Operation History</b> - records an operation
                  in a particular relational table. It has the schema and table names,
                  the GUID of the <u>Actor</u> that performed this operation, the operation type (Create/Update/Delete)
                  and the order of that operation in the current Transaction History
                  record.
                  <ul>
                    <b>Record History</b> - contains the <u>Actor GUID</u> and the
                    <u>Actor Record Id</u> for the record. The Actor GUID represents
                    the Actor that created the record and is needed for Update
                    and Delete operations. It may be different from the Actor who
                    performed the operation (stored in Operation History).
                    <ul>
                      <li><b>Record History New Value</b> - has the column name
                        and the value that is being Inserted or Updated in that column
                        (for the record of the containing <u>Record history</u>)</li>
                      <li><b>Record History Old Value</b> - has the column name
                        and the value that is being Deleted or Replaced (with an Update
                        operation)</li>
                    </ul>

                  </ul>
                </ul>
              </li>
            </ul>
            <p>
              Each Transaction History carries with it all of the information
              on the Actors that performed the operations in that Transaction.
            </p>
            <div class="alert alert-info mb-4">
              <span class="badge badge-info text-uppercase">Note:</span> In
              practice, each operation also stores the API signature
              that was used to make that operation as well as the chain
              of all parent API calls (if any). This allows for Application
              discoverability by the users that are loading the Repository.
              AIRport can then suggest what Applications should be
              used to handle the Repository (and the Application descriptor can
              suggest what clients should be used to view the data).
            </div>
          </section>

          <hr class="divider">

          <section id="AIR-autonomous">
            <h3>AIR - Autonomous</h3>
            <p>Repositories are <b>Autonomous</b> because each Repository
              contains all of the information needed to be useful. That is,
              it can be used by itself, without any other Repositories. This
              refers to the fact that Repositories may reference each other's
              records. That is, a record in one Repository may have a
              foreign key to a record in another Repository.
            </p>
            <p>When a Repository references records from other
              Repositories those records get copied to the referring Repository.
              This is what allows the referring repository to remain autonomous.
              The copied records have the state of the original records as it
              was when they were copied. The new
              record copies may then be updated and may diverge from the
              state of the records they were copied from (in referenced
              Repositories).
            </p>
            <p>The copy process is recursive for all records that are, in turn,
              pointed to by the foreign keys in the (top level) copied records.
              This means that no matter how deep the foreign key references go,
              they all get copied into the referring Repository.
            </p>
            <p>This has the effect of making sure that Joins (made on the
              tables where the Repository resides) always return data
              for the views to display. Thus, a Repository may be loaded
              (and will always be usable) by itself, even if it has nested
              references to records in many other Repositories.
            </p>
          </section>

          <hr class="divider">

          <section id="AIR-interdependent">
            <h3>AIR - Interdependent</h3>
            <p>When records are copied into a Repository from
              other Repositories, the original <b>Repository GUID</b>,
              <b>Actor GUID</b> and <b>Actor Record Id</b> are retained
              in separate columns. Along with them, the global address of the
              Repository is retained as well, allowing AIRport to
              lookup the referenced Repository (the source of the
              originally copied records).
            </p>
            <p>These "original" Ids are retained in another set of keys
              that do not have foreign key constraints on them. AIRport
              can then be instructed to take a given Query and run it
              in cross-Repository mode. When doing so AIRport
              will use LEFT JOINs and progressively load missing
              Repositories and re-query until it returns complete
              object graphs with all of the records from the original
              Repositories.
            </p>
            <p>
              The query process may be slow (due to necessary network
              round trips to retrieve additional Repositories) but
              may be served via Observables, allowing the UIs to
              progressively load more data as it becomes available.
            </p>
            <p>Thus Repositories are <b>Interdependent</b> and the UIs
              can make the choice of viewing the Repository-local
              data only, or loading the cross-Repository view,
              that may at first return Repository-local data and
              then can fill in the data across referenced
              Repositories.
            </p>
          </section>

          <hr class="divider">

          <!-- AIRport
		============================ -->
          <section id="AIRport">
            <h2>AIRport</h2>
            <p class="lead mb-5">
              AIRport is a DApp Runtime. It encapsulates decentralized storage,
              provides API and persistence frameworks, and standardizes API calls.
            </p>
            <p>
              AIRport implements Autonomous Interdependent Repositories. It provides
              a common runtime on which Decentralized Applications can
              run and be accessed by Clients such as Web UIs.
            </p>

            <img src="./images/AIRport_diagram_1.png" class="img-fluid"
              alt="AIRport Autonomous Interdependent Repository implementation">

            <div class="alert alert-info mb-4">
              <span class="badge badge-info text-uppercase">Example:</span>
              An Chat App creates a schema for storing user conversations. A second
              App for Events has an event management schema and uses the Chat App schema
              for chats associated with events. A third App computes Event Statistics
              and uses the schema of the Events App.
              <br>
              <br>
              Alice has the Event App and the Chat App installed in AIRport (
              on her device). Charlie has the Chat App and the Event Stats App
              installed on his device. The Event Stats App automatically installs
              the Event App and its schema.
              <br>
              <br>
              The data for all three Apps is
              stored in Chat/Event specific Repositories, one repository per chat/event.
              Alice has "Event A" and "Event B" that are not shared with Charlie. Alice and
              Charlie share "Event C" and its chat. They participate in another "Chat
              D" that isn't associated with any event. Charlie has a "Chat E"
              that isn't shared with Alice.
            </div>

            <p>
              The core functionality provided by AIRport is:
            </p>
            <ul>
              <li>
                Database ORMs and entity state management.
              </li>
              <li>
                API interfaces for UI-to-App and App-to-App interaction.
              </li>
              <li>
                Transactions & Scope.
              </li>
              <li>
                Cross-database data synchronization.
              </li>
            </ul>
          </section>

          <!-- 
		============================ -->
          <!-- ORM
          -->
          <section id="AIRport-ORM">
            <h3>ORM & State</h3>
            <p>
              Default <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">
                ORM framework</a> for AIRport is
              <a href="https://github.com/beyond-decentralized/AIRport/tree/master/ORMs/tarmaq">
                Tarmaq</a>. It provides:
            </p>
            <ul>
              <li><b><a href="https://github.com/beyond-decentralized/AIRport/tree/master/ORMs/tarmaq/entity">Entity
                    Mapping API</a></b>: Entity and Property decorators in JPA style.</li>
              <li><b><a href="https://github.com/beyond-decentralized/AIRport/tree/master/ORMs/tarmaq/query">Query
                    API</a></b>: TypeScript integrated SQL statements with SELECT clause as entity tree.</li>
              <li><b><a href="https://github.com/beyond-decentralized/AIRport/tree/master/ORMs/tarmaq/dao">DAO
                    API</a></b>: Strongly typed entry points into the Query API.</li>
            </ul>
            <p>AIRport supports creation of additional
              <a href="https://github.com/beyond-decentralized/AIRport/tree/master/ORMs">
                ORMs</a>. All ORMs can return
              <a
                href="https://github.com/beyond-decentralized/AIRport/blob/master/ORMs/tarmaq/query/doc/query/query_types/entity_graph_query.md">
                fully interlinked graphs
              </a> of Entity objects. Support for traditional SQL result sets is also available.
            </p>
            <p>
              AIRport has sessionless entity state management. All entity
              objects returned by the ORM contain a hidden property with the
              original state of the entity. When the entities are saved, AIRport
              calculates diffs on the entity objects (using the original object
              state) and performs the necessary updates. Tracking original state
              removes the need for maintaining Hibernate-like ORM sessions and
              insulates edited objects from possible state overwrites (due to remotely
              made updates to the same objects).
            </p>
          </section>

          <hr class="divider">

          <!-- API
		============================ -->
          <!--
          -->
          <section id="AIRport-API">
            <h3>API</h3>
            <p>
              AIRport Apps run in isolated VMs inside AIRport. Clients (UIs)
              communicate with Apps via AIRport:
            </p>
            <img src="./images/AIRport_architectural_diagram.drawio.png" class="img-fluid"
              alt="AIRport Client to App communication">
            <p>
              Apps define API methods by decorating them with @Api() decorator.
              AIRport generates SOAP like stubs for Clients and other Apps
              to use. Invoking those stubs sends requests to AIRport which
              forwards them to Apps where they are from (loading missing Apps
              when necessary).
              The default import of an Application contains just the API
              stubs. A separate bundle is created for Application itself (and
              is deployed as a standardized URL for AIRport to load into IFrames).
            </p>
            <p>
              App VMs are run in IFrames. Because Application server domains
              differ, Apps are isolated from AIRport and other Apps (from
              different domains). The only way Apps can interact with
              AIRport and other Apps is via the API framework defined
              by AIRport.
            </p>
            <p>
              Apps cannot directly access the relational database
              hosted by AIRport and must make standardized persistence requests
              (via provided ORMs) that are pre-processed and sanitized by
              AIRport.
            </p>
            <p>
              Apps can join to tables in schemas of other Apps. Apps cannot
              directly modify data in schemas that belong to other Apps.
              Apps must call APIs defined by other Apps to make data
              modifications (in schemas of those other Apps).
            </p>
          </section>

          <hr class="divider">

          <!-- 
		============================ -->
          <!-- Transactions
          -->
          <section id="AIRport-Transactions-n-Scope">
            <h3>Transactions & Scope</h3>
            <p>
              Every API call that goes through AIRport get's its own
              savepoint. This means that if an API method fails and
              throws an Error, all of its database operations (and
              operations of API methods it itself called) will be
              rolled back. If an API method is wrapped in a
              "try {} catch(e) {}" block, catching the Error will
              allow the calling API method to do additional processing
              (and database operations) even if its nested API calls
              failed.
            </p>

            <div class="alert alert-warning mb-4">
              <span class="badge badge-warning text-uppercase">NOTE:</span>
              Currently, API methods called within
              the same Application will NOT get their own savepoints.
              That is, there are only savepoints for
              API calls made across Applications.
            </div>

            <p>
              Transaction tracking is implemented behind the scenes,
              without requiring the developers to pass transaction objects
              around. In the same way, request information for an API
              operations is also implemented in the background. API
              services and DAOs can just:
            </p>
            <pre><code>
    @Inject()
    requestManager: RequestManager
            </code></pre>
            to get access to the Actor and User of the API call (
            as well as additional information about the request).
          </section>

          <hr class="divider">

          <!-- 
		============================ -->
          <!-- Synchronization
          -->
          <section id="AIRport-Synchronization">
            <h3>Synchronization</h3>
            <p>
              AIRport handles synchronization of Repositories
              across multiple devices. If there are synchronization conflicts
              AIRport automatically resolves them based on modification
              timestamps (with latest modification winning) and records conflict
              resolutions and their outcomes in Repository transaction history.
              UIs can hook into that resolution history and notify the Users
              that there were conflicts. UIs can also present to the Users
              what the conflicting values were and allow the Users to manually
              overwrite automatic resolution outcomes.
            </p>
          </section>

          <hr class="divider">


          <!-- AIRbridge
		============================ -->
          <section id="AIRbridge">
            <h2>AIRbridge</h2>
            <p class="lead mb-5">
              AIRbridge is a collection of libraries that will integrate
              AIRport with Applications and Storage platforms.
            </p>

            <p>
              The currently scoped-out functionality to be provided by AIRbridge is:
            </p>
            <ul>
              <li>
                Per-Repository private blockchain.
              </li>
              <li>
                A convenient Single Sign On solution and a high security one.
              </li>
              <li>
                Optimized data transfer library with support for future use cases.
              </li>
              <li>
                Entity based validation library for closing the Client-Server gap.
              </li>
            </ul>
          </section>

          <hr class="divider">

          <!-- Blockchain
		============================ -->
          <!--
          -->
          <section id="AIRbridge-Blockchain">
            <h3>Blockchain</h3>
            <p>
              Each Repository should be secured by its own private blockchain.
              Each Actor will sign its transactions with its own private key.
              Actor keys will be stored in a User specific Repository,
              dedicated to key storage. All key in this Repository will be
              encrypted by user's Master key.
            </p>
            <p>
              A Repository can, optionally, be encrypted by a symmetric key.
              This key should be distributed to each of the Repository
              members.
            </p>
            <p>
              Blockchains keep track of the order of the transactions. There
              may be multiple sub-chains, depending on the state of the
              chained Transaction Logs on each of the member relational
              databases. Automatic conflict resolution will put new
              blocks in the chain. The blockchain should be eventually
              consistent, always leading to a consistent state from all
              sub-chains.
            </p>
          </section>

          <hr class="divider">

          <!-- SSO
		============================ -->
          <!--
          -->
          <section id="AIRbridge-SSO">
            <h3>SSO</h3>
            <p>
              There should be an easy and convenient way for Users to
              sign into their local AIRport instance. AIRbridge should
              implement Open ID protocol for validating users. There
              should be a convenient way for users to recover their
              passwords.
            </p>
            <p>
              There should also be a high securty way to authenticate
              in AIRport that does not rely on third parties for
              handling sensitive data.
            </p>
            <p>
              User Master key should be derivable from the User's
              password, which should be secure against sub-quantum
              attacks in the convenient implementation (Ex: 15 characters,
              numbers and special, different caseing) and resistant to
              quantum attacks in the high security implementation.
            </p>
          </section>

          <hr class="divider">

          <!-- Transfer
		============================ -->
          <!--
          -->
          <section id="AIRbridge-Transfer">
            <h3>Transfer</h3>
            <p>
              There should be a way for data to be correctly and efficiently
              transferred between the Clients and the Apps within AIRport.
              It should protect Apps from any code injection and alike
              attacks. It should allow for passing API (method) parameter
              modifications back to the calling clients.
            </p>
            <p>
              Data transfer should be designed with future use cases in mind.
              It should support multi-source scenarios where Client may
              query both a remote Application host (via server-side AIRport
              nodes) and a local (private) AIRport instance, at the same
              time.
            </p>
            <p>
              The data transfer library should support all major decentralized
              storage technologies, free cloud storage solutions like Google
              Drive, and should also work in scenarios where
              Repositories are stored centrally.
            </p>
          </section>

          <hr class="divider">

          <!-- Validation
		============================ -->
          <!--
          -->
          <section id="AIRbridge-Validation">
            <h3>Validation</h3>

            <div class="alert alert-info mb-4">
              <span class="badge badge-info text-uppercase">NOTE:</span>
              AIRport is designed to bridge the client-server gap.
              Objects passed as parameters to API calls retain all changes when returned
              to the Client. And, objects passed into DAO.save methods are automatically
              updated to the saved state. Thus, there is no need for the Client to query for
              the new entity state (of the just saved entity objects). That state is
              automatically updated in the parameter object passed from the Client (the
              objects that were sent to the API to be saved).
              <br>
              <br>
              Likewise, AIRport integrates data in the opposite (Client to Server)
              direction. The entity objects returned by APIs contain their original
              (previous) state (in a hidden/private property). The Client makes
              modifications to objects and sends them back. DAO.save calls then use the
              original (previous) state to determine which properties were modified.
              If the passed-in objects don't have the original state (or IDs) they are
              treated as new objects. DAO.save calls will persist all objects in the
              passed in object trees that are new/updated/to be deleted (as long as
              those objects are in the schema of the Application).
            </div>
            <p>Seamless integration of client and server requires strict validation
              of all data that is passed into Application APIs. Validating with standard
              procedural code is both verbose and error prone. AIRbridge validation
              uses declarative programming and automation to distil validation logic
              down to its essence.
            </p>
            <p>
              AIRport validation leverages the Database Entity definitions and provides
              a type safe API that declaratively describes the desired (valid)
              state of the passed in entity tree. AIRport provides a validation DSL (in
              the form of
              validation functions, tied to the JSON entity tree declaration).
              All passed in state that is not validated is automatically flagged.
              All objects that are not validated are excluded from persistence operations.
              Non-validated properties (with new/modified values) on validated objects
              cause validation to fail.
            </p>
            <div class="alert alert-info mb-4">
              <span class="badge badge-info text-uppercase">NOTE:</span>
              Passing entity objects across API boundaries is optional in AIRport.
              Developers can choose to use <a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTOs</a>.
              Also, developers are not required to use then AIRbridge declarative
              validation engine and can write manual validation logic.
            </div>
          </section>

          <hr class="divider">

          <!-- AIRway
		============================ -->
          <section id="AIRway">
            <h2>AIRway</h2>
            <p class="lead mb-5">
              User devices should be able to communicate directly with each other.
            </p>

            <p>
              AIRport stores repositories in decentralized file systems. Keeping
              track of new modifications to these requires constant polling. This
              is slow and adds extra load on the storage providers, increasing costs.
              There should be a way for end user devices to communicate directly
              with each other. The devices should be aware of what Repositories
              are shared between them and should pass updates to those Repositories
              appropriately.
            </p>
          </section>

          <hr class="divider">

          <!-- Highway
		============================ -->
          <section id="Highway">
            <h2>Highway</h2>
            <p class="lead mb-5">
              Highway is AIR for the server environment.
            </p>

            <p>
              Goal of Highway is to let local communities own their
              data while allowing global users to search it and contribute
              to it. The initial use case for it is a social network
              where locally operated and owned
              franchises host community data.
            </p>
            <p>Technologically this can be accomplished by leveraging
              existing technologies such as globally shardable
              <a href="https://www.cockroachlabs.com/">
                CockroachDB</a> and <a href="https://www.scylladb.com/">
                ScyllaDB</a> databases. Autonomous Interdependent Repositories
              are used for integration with private user data,
              for performance benefits and to provide an eventual
              migration path to <a href="#maglev">Maglev</a>.
            </p>

            <img src="./images/Highway_architecture.drawio.png" class="img-fluid" alt="Highway architecture">

            <p>
              Highway will work by sending modification requests to the
              server, where they will be processed and placed into
              a distributed relational database. Because Highway
              data is stored in Repositories, read queries will go
              against a wide column store. Transaction logs will be
              pulled into the client-side AIRport engine where
              relational data will be reconstructed and queried. AIRport
              will monitor incoming transaction log entries and serve
              data via Observable feeds.
            </p>
            <p>
              Highway will allow Applications from multiple providers
              to access and add to community owned data. Apps will access
              data across Application schemas and modify data in their own
              own schemas. This will be done based on rules
              specified by the community owned hosting franchises.
            </p>
            <p>
              Applications will run in VMs and will have access to
              only the APIs specified by AIRport, thus preventing
              abuse of community data.
            </p>
            <div class="alert alert-info mb-4">
              Based on work done by <a href="https://turbase.app">Turbase DAO</a>,
              advertisement revenue received from using
              community data will stay in the locally owned franchises.
            </div>
          </section>

          <hr class="divider">

          <!-- Maglev
		============================ -->
          <section id="Maglev">
            <h2>Maglev</h2>
            <p class="lead mb-5">
              Maglev is the AIR Internet. It connects Highway providers.
            </p>
            <p>
              Maglev is about allowing organizations to interoperate
              in an ecosystem of Repositories.
            </p>

            <img src="./images/Maglev_architecture.drawio.png" class="img-fluid" alt="Highway architecture">

            <p>
              AIRport can run on a trusted network of execution nodes
              (a la blockchain validator nodes) and work with Repositories
              from multiple Organizations. Running AIRport on execution
              nodes ensures fairness and security of data processing and
              protects organizations and their data. AIRport can
              enforce data sharing and modification rules specified by
              each organization that hosts the data. Under those rules it
              can allow third party Applications access organization (and
              community) owned data. AIRport execution nodes can work in
              concert with Client-side AIRport engines to give views on
              decentralized data, combined with "organization distributed"
              data.
            </p>
          </section>

          <hr class="divider">

          <!-- Blog
		============================ -->
          <section>
            <h2>Blog</h2>
            <p>
              Check out the
              <a href="blog.html">Blog</a>
              for the latest developments in Beyond Decentralized technology.
            </p>
          </section>

        </div>
      </div>

    </div>
    <!-- Content end -->

    <!-- Footer
  ============================ -->
    <footer id="footer" class="section bg-dark footer-text-light">
      <div class="container">
        <p class="text-2 text-center mb-0">Design by <a class="btn-link" target="_blank"
            href="http://www.harnishdesign.net/">HarnishDesign</a>.</p>
      </div>
    </footer>
    <!-- Footer end -->

  </div>
  <!-- Document Wrapper end -->

  <!-- Back To Top -->
  <a id="back-to-top" data-toggle="tooltip" title="Back to Top" href="javascript:void(0)"><i
      class="fa fa-chevron-up"></i></a>

  <!-- JavaScript
============================ -->
  <script src="assets/vendor/jquery/jquery.min.js"></script>
  <script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <!-- Highlight JS -->
  <script src="assets/vendor/highlight.js/highlight.min.js"></script>
  <!-- Easing -->
  <script src="assets/vendor/jquery.easing/jquery.easing.min.js"></script>
  <!-- Magnific Popup -->
  <script src="assets/vendor/magnific-popup/jquery.magnific-popup.min.js"></script>
  <!-- Custom Script -->
  <script src="assets/js/theme.js"></script>
</body>

</html>