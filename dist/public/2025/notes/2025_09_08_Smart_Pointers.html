<h1>Smart pointers (and Groups)</h1>
A core concern of BD stack (AIRport and related AIR frameworks) is protection of user data.  While
Apps and UIs do not store the data they can still access it.  In Phase 1 they will execute as
JavaScript and will be scanned for any browser API access to prevent leaking data outside of the
platform.  However they can still leak data across Groups.
<br>
<br>
NOTE: A Group [ previously thought of as an Organization, which better fits a DIN term for the
entity(ies) running a DIN (Sub-)Tree ] ties in one or more Users with one or more Repositories
[hypothetically also possibly across multiple Organizations].  A Group shares a set of Repositories
with data related to that Group.
<br>
<br>
One of the core benefits of the AIR technology is that any number of Groups can be loaded into a
Leaf (personal and possibly temporary) database.  This allows the User to see their data across
multiple groups and possibly modify it across those Groups (e.g. checking off all tasks for an
event related to multiple Groups).
<br>
<br>
This however means that by default there is no way to prevent data leakage from one Group to
another.  A rudimentary way of preventing such leakages is strong control over the code of Apps
 and UIs but such an approach goes against the second goal of BD - Independent Software Development
(and does not scale).  The latest (** *Update* 9/12/2025**) (now arrived at) plan (related to this) is to have Organizations
host *framework*, Apps and UIs of their choice and have the Turbase serve only the ~framework code, App & UI
Version verification hashes, and a Map of Organization Addresses by User Email (one-way) hash (for
the location of the User's KeyRing Repository) - this provides some but very loose control~ *listing of Tree Nodes, effectively becoming an ?"Orchard Garden"?. User-server-branch interaction with be fully contained, with cross Leaf Connection Establishment being done via each Leaf Node's own branch, with Trees exchanging user IPs if necessary - real leads only connect to Their branch - 9/12/2025).*
<br>
<br>
The first iteration of how to manage separation of data between Groups relied on the idea of
declarative UIs and Apps, which do not have executable code and at the lowest level operate on 
Block Code (executed in an Engine).  This approach best fits Laymen-created Apps and UIs and may
eventually be necessary to allow non-developer Users tie in various Apps into custom functionality
bundles.  But it adds a lot of execution overhead, requires additional software layers and does not
fit the Phase 1 objectives (and beyond).
<br>
<br>
Today the second, Phase 1-3 acceptable solution was discovered - Smart Pointers.  This means
keeping track of the Repository a given pointer to the data points to, or in the case of computed
values - from which Repositories the pointed-to data was computed.
<br>
<br>
This approach has several advantages:
<br>
<ul>
    <li>
        It doesn't introduce any additional logic complexity.  In JavaScript this is accomplished
        by having Proxy objects wrap the pointed to objects (or even primitives), and
        AssemblyScript by AST tree modifications.
    </li>
    <li>
        It does not impose any constraints on the type of code that can be written - no need for
        declarative syntax or an engine to execute it.
    </li>
    <li>
        It doesn't impact Phase 1: nothing needs to be written to deliver the first iteration - it
        can be seamlessly added at a later point.
    </li>
    <li>
        It allows for computed or referenced data across Groups where such data relationships are
        allowed.
    </li>
    <li>
        It allows for any App to function as long as it doesn't break the defined Group Repository
        boundaries, simply preventing the data that isn't properly linked from being saved.
    </li>
</ul>
The cost of this approach is that the Application code has to be compiled before it is allowed to
execute.  However, given that Phase 2 target platform for Apps is AssemblyScript (which can
optionally be complied in-browser, if App Version hashes are not available) and for UIs is Svelte
(which can also be compiled in-browser) this isn't a hard stop and simply requires plugins into
these two compilers (AST modifications are supported by AssemblyScript and Svelte output can be
post-processed).
<br>
<br>
Additionally smart pointers will optimize GC implementation in WASM Apps (and beyond), given that
Reference Counting is a (with high-level research) perfect fit for Session Level (per loaded App)
memory management. Session Level storage (as tentatively planned) will only allow a top level Map
for data objects (with ability to store sub-Maps), hypothetically eliminating the cyclic reference
problem, only requiring counter overhead for a sub-object when its pointer is changed and keeping
GC pauses low given the tree-like nature of the data structure.  Provided that an App can only be
executed by a single OS thread, GC implementation should fit Phase 2-3 (and beyond) Real-Time
requirements.
<br>
<br>
Going forward this will also allow (with optional instrumentation) to gather information on App and
individual API memory usage and GC frequency, as well as information on UI data volumes.